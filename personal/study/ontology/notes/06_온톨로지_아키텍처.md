# 온톨로지 기반 시스템 아키텍처

## 시맨틱 웹 아키텍처 스택

```
┌─────────────────────────────────────┐
│         User Interface              │  사용자 인터페이스
├─────────────────────────────────────┤
│         Application Logic           │  애플리케이션 로직
├─────────────────────────────────────┤
│    Trust & Proof (미래)             │  신뢰 & 증명
├─────────────────────────────────────┤
│    Unifying Logic                   │  통합 논리
├─────────────────────────────────────┤
│    OWL (Ontology)                   │  온톨로지 계층
├─────────────────────────────────────┤
│    RDF + RDFS                       │  데이터 모델
├─────────────────────────────────────┤
│    SPARQL                           │  쿼리 언어
├─────────────────────────────────────┤
│    XML + Namespace                  │  구문
├─────────────────────────────────────┤
│    URI / IRI                        │  식별자
├─────────────────────────────────────┤
│    Unicode                          │  문자 인코딩
└─────────────────────────────────────┘
```

## 온톨로지 시스템 구성 요소

### 1. 데이터 계층

```
┌─────────────────────────────────────┐
│  Triple Store (RDF 저장소)          │
│  - Apache Jena Fuseki               │
│  - GraphDB                          │
│  - Virtuoso                         │
│  - Neo4j (with neosemantics)        │
└─────────────────────────────────────┘
         ↕ SPARQL Protocol
┌─────────────────────────────────────┐
│  온톨로지 파일 (.ttl, .owl, .rdf)   │
└─────────────────────────────────────┘
```

**주요 Triple Store 비교**:

| 특징 | Apache Jena | GraphDB | Virtuoso | Stardog |
|------|-------------|---------|----------|---------|
| 라이선스 | 오픈소스 | 무료/상용 | 오픈소스/상용 | 상용 |
| 추론 | 제한적 | 강력 | 중간 | 강력 |
| 성능 | 중간 | 높음 | 매우 높음 | 높음 |
| 사용 난이도 | 쉬움 | 중간 | 어려움 | 중간 |

### 2. 추론 계층

```
┌─────────────────────────────────────┐
│  추론 엔진                          │
│  - HermiT (OWL 2 DL)                │
│  - Pellet (OWL 2)                   │
│  - ELK (OWL 2 EL, 빠름)             │
│  - Fact++ (OWL 2 DL)                │
└─────────────────────────────────────┘
         ↕
┌─────────────────────────────────────┐
│  추론 결과 캐시                     │
└─────────────────────────────────────┘
```

**추론 전략**:
1. **사전 추론 (Materialization)**: 미리 계산하여 저장
2. **실시간 추론 (Query Rewriting)**: 쿼리 시점에 추론
3. **하이브리드**: 일부는 사전, 일부는 실시간

### 3. 서비스 계층

```
┌─────────────────────────────────────┐
│  SPARQL Endpoint                    │
│  - HTTP REST API                    │
│  - SELECT, ASK, CONSTRUCT, DESCRIBE │
│  - UPDATE (INSERT, DELETE)          │
└─────────────────────────────────────┘
         ↕ HTTP
┌─────────────────────────────────────┐
│  비즈니스 로직                      │
│  - 쿼리 생성                        │
│  - 결과 변환                        │
│  - 캐싱                             │
└─────────────────────────────────────┘
```

### 4. 애플리케이션 계층

```
┌─────────────────────────────────────┐
│  백엔드 API                         │
│  - Python (rdflib, owlready2)       │
│  - Java (Apache Jena)               │
│  - JavaScript (rdflib.js)           │
└─────────────────────────────────────┘
         ↕ JSON/GraphQL
┌─────────────────────────────────────┐
│  프론트엔드                         │
│  - React/Vue/Angular                │
│  - 그래프 시각화 (D3.js, Cytoscape) │
└─────────────────────────────────────┘
```

## 아키텍처 패턴

### 1. 중앙집중형 (Centralized)

```
         ┌──────────────┐
         │   Client 1   │
         └──────┬───────┘
                │
         ┌──────▼───────┐
         │   Client 2   │
         └──────┬───────┘
                │
         ┌──────▼───────┐
         │  SPARQL      │
         │  Endpoint    │
         └──────┬───────┘
                │
         ┌──────▼───────┐
         │ Triple Store │
         │  + Ontology  │
         └──────────────┘
```

**장점**:
- 단순한 구조
- 일관성 유지 쉬움
- 관리 편리

**단점**:
- 단일 장애점
- 확장성 제한
- 네트워크 지연

**적합한 경우**: 소규모, 사내 시스템

### 2. 분산형 (Distributed/Federated)

```
┌──────────┐    ┌──────────┐    ┌──────────┐
│ Endpoint │    │ Endpoint │    │ Endpoint │
│    A     │    │    B     │    │    C     │
└────┬─────┘    └────┬─────┘    └────┬─────┘
     │               │               │
     └───────────┬───┴───────────────┘
                 │
           ┌─────▼──────┐
           │  Mediator  │
           │   Layer    │
           └────────────┘
```

**장점**:
- 확장 가능
- 장애 복원력
- 지역 데이터 유지

**단점**:
- 복잡도 증가
- 일관성 문제
- 쿼리 성능 저하

**적합한 경우**: 대규모, 다기관 협업

### 3. 하이브리드 (Hybrid)

```
┌─────────────────────────────────────┐
│        Application Layer            │
└───────────┬─────────────────────────┘
            │
     ┌──────▼──────┐
     │    Cache    │  ← 자주 사용하는 데이터
     └──────┬──────┘
            │
     ┌──────▼──────┐
     │  SPARQL     │
     │  Endpoint   │
     └──────┬──────┘
            │
     ┌──────▼──────────────┐
     │  Triple Store       │
     │  + Core Ontology    │
     └─────────────────────┘
```

**장점**:
- 성능 최적화
- 유연성
- 점진적 도입

**적합한 경우**: 대부분의 실전 시스템

## 실전 아키텍처 예시

### 예시 1: Doubless 피트니스 시스템

```
┌─────────────────────────────────────────┐
│  웹 대시보드 (React)                    │
│  - 회원 관리                            │
│  - 급여 분석 리포트                     │
└──────────────────┬──────────────────────┘
                   │ REST API
          ┌────────▼─────────┐
          │  FastAPI Backend │
          │  - Python        │
          └────────┬─────────┘
                   │
     ┌─────────────┼─────────────┐
     │             │             │
┌────▼────┐  ┌────▼────┐  ┌────▼────┐
│SQLite   │  │ RDF     │  │ 추론    │
│ (급여)  │  │ Store   │  │ 엔진    │
│         │  │(관계)   │  │         │
└─────────┘  └─────────┘  └─────────┘
                   │
          ┌────────▼─────────┐
          │ Fitness Ontology │
          │ - 트레이너-회원  │
          │ - 운동-장비      │
          └──────────────────┘
```

**데이터 흐름**:
1. **급여 데이터**: SQLite → Python → JSON API
2. **관계 데이터**: RDF Store → SPARQL → JSON
3. **추론**: "이 회원에게 적합한 트레이너는?" → 추론 엔진
4. **통합**: Backend에서 두 소스 결합

### 예시 2: 지식 기반 추천 시스템

```
┌─────────────────────────────────────────┐
│           User Interface                │
└──────────────────┬──────────────────────┘
                   │
┌──────────────────▼──────────────────────┐
│      Recommendation Engine              │
│  ┌────────────┐     ┌────────────┐      │
│  │  Content   │     │Collaborative│     │
│  │  Filtering │     │  Filtering  │     │
│  └──────┬─────┘     └──────┬──────┘     │
│         └──────────┬────────┘            │
│                    │                     │
│         ┌──────────▼─────────┐           │
│         │   Semantic Layer   │           │
│         │  (Ontology-based)  │           │
│         └──────────┬─────────┘           │
└────────────────────┼─────────────────────┘
                     │
          ┌──────────▼──────────┐
          │   Knowledge Graph   │
          │  - User Ontology    │
          │  - Item Ontology    │
          │  - Context Ontology │
          └─────────────────────┘
```

**추론 활용**:
```sparql
# "운동 초보자에게 적합한 운동 추천"
PREFIX fitness: <http://example.org/fitness#>

SELECT ?exercise ?trainer
WHERE {
    ?user fitness:skillLevel "beginner" ;
          fitness:preferredMuscle ?muscle .

    ?exercise fitness:difficulty "easy" ;
              fitness:targets ?muscle ;
              fitness:requires ?equipment .

    ?trainer fitness:specializes ?exercise ;
             fitness:teachingStyle "patient" .

    FILTER NOT EXISTS {
        ?user fitness:hasInjury ?injury .
        ?exercise fitness:stressesBodyPart ?injury .
    }
}
```

## 성능 최적화 전략

### 1. 인덱싱
```
# Triple Store 인덱스
- SPO (Subject-Predicate-Object)
- PSO (Predicate-Subject-Object)
- OPS (Object-Predicate-Subject)
- SOP, POS, OSP
```

### 2. 캐싱 계층

```python
from functools import lru_cache
from rdflib import Graph

@lru_cache(maxsize=1000)
def query_ontology(sparql_query: str):
    g = Graph()
    g.parse("ontology.ttl")
    results = g.query(sparql_query)
    return list(results)
```

### 3. 쿼리 최적화

**비효율적**:
```sparql
SELECT ?person ?friend ?friendOfFriend
WHERE {
    ?person foaf:knows ?friend .
    ?friend foaf:knows ?friendOfFriend .
    ?person foaf:name "Alice" .  # 늦게 필터링
}
```

**효율적**:
```sparql
SELECT ?person ?friend ?friendOfFriend
WHERE {
    ?person foaf:name "Alice" .  # 먼저 필터링
    ?person foaf:knows ?friend .
    ?friend foaf:knows ?friendOfFriend .
}
```

### 4. 물리화 (Materialization)

```
# 추론 결과를 미리 계산하여 저장
사전 추론: 10분 (1회)
쿼리 시간: 10ms

vs

실시간 추론:
쿼리 시간: 5초 (매번)
```

## 배포 아키텍처

### Docker 기반 배포

```yaml
# docker-compose.yml
version: '3.8'

services:
  fuseki:
    image: stain/jena-fuseki
    ports:
      - "3030:3030"
    volumes:
      - ./ontology:/fuseki/ontology
      - fuseki-data:/fuseki

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - SPARQL_ENDPOINT=http://fuseki:3030/ds
    depends_on:
      - fuseki

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend

volumes:
  fuseki-data:
```

### 클라우드 배포

```
┌─────────────────────────────────────┐
│      Load Balancer (AWS ALB)        │
└──────────────┬──────────────────────┘
               │
    ┌──────────▼──────────┐
    │   API Gateway       │
    └──────────┬──────────┘
               │
    ┌──────────▼──────────┐
    │  ECS/Kubernetes     │
    │  - Backend Pods     │
    │  - SPARQL Endpoint  │
    └──────────┬──────────┘
               │
    ┌──────────▼──────────┐
    │  RDS/DocumentDB     │
    │  - Triple Store     │
    └─────────────────────┘
```

## 보안 고려사항

### 1. 접근 제어

```turtle
# 온톨로지에 접근 제어 정의
@prefix acl: <http://www.w3.org/ns/auth/acl#> .

:MedicalRecordAccess
    acl:accessTo :MedicalRecords ;
    acl:mode acl:Read ;
    acl:agent :Doctor ;
    acl:agentClass :MedicalStaff .
```

### 2. SPARQL 인젝션 방지

```python
# ❌ 취약한 코드
def get_person(name):
    query = f"SELECT * WHERE {{ ?person foaf:name '{name}' }}"
    return g.query(query)

# ✅ 안전한 코드
from rdflib.plugins.sparql import prepareQuery

def get_person_safe(name):
    query = prepareQuery("""
        SELECT * WHERE {
            ?person foaf:name ?name
        }
    """)
    return g.query(query, initBindings={'name': Literal(name)})
```

### 3. 데이터 암호화

- **전송 중**: HTTPS/TLS
- **저장 시**: 데이터베이스 암호화
- **민감 정보**: 별도 암호화 (SSN, 의료 정보)

## 모니터링 & 로깅

```python
import logging
from time import time

def log_sparql_query(query: str):
    logger = logging.getLogger('ontology')
    start = time()

    try:
        results = g.query(query)
        duration = time() - start
        logger.info(f"Query succeeded in {duration:.2f}s")
        logger.debug(f"Query: {query}")
        return results
    except Exception as e:
        logger.error(f"Query failed: {e}")
        logger.error(f"Query: {query}")
        raise
```

## 실습 과제

### 과제 1: 로컬 온톨로지 서버 구축
1. Apache Jena Fuseki 설치
2. 피트니스 온톨로지 업로드
3. SPARQL 쿼리 실행
4. Python에서 연결

### 과제 2: API 서버 구축
1. FastAPI로 REST API 생성
2. SPARQL 쿼리를 JSON으로 변환
3. 캐싱 구현
4. Swagger 문서 생성

### 과제 3: Docker 배포
1. docker-compose.yml 작성
2. 컨테이너 빌드 및 실행
3. 서비스 간 통신 테스트

## 핵심 요점

1. **계층화**: 데이터 - 추론 - 서비스 - 애플리케이션
2. **Triple Store 선택**: 요구사항에 맞는 솔루션
3. **추론 전략**: 사전 vs 실시간 vs 하이브리드
4. **성능 최적화**: 인덱싱, 캐싱, 쿼리 최적화
5. **보안**: 접근 제어, 인젝션 방지, 암호화

## 참고 자료

- [Apache Jena Documentation](https://jena.apache.org/documentation/)
- [GraphDB Documentation](https://graphdb.ontotext.com/documentation/)
- [Semantic Web Architecture](https://www.w3.org/2001/sw/)

---

**학습일**:
**완료 여부**: [ ]
**실습 완료**: [ ]
