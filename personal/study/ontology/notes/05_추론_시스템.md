# 온톨로지 추론 시스템

## 추론(Reasoning)이란?

**추론**은 명시적으로 작성된 지식으로부터 새로운 지식을 자동으로 유도하는 과정입니다.

### 예시
```turtle
# 명시적 지식
John hasParent Mary .
hasParent inverseOf hasChild .

# 추론된 지식 (자동 유도)
Mary hasChild John .
```

## 추론의 종류

### 1. 연역 추론 (Deductive Reasoning)
- 일반적 규칙에서 구체적 사실 도출
- 논리적으로 확실
- 온톨로지 추론의 기본

```
규칙: 모든 사람은 동물이다
사실: John은 사람이다
결론: John은 동물이다 (확실)
```

### 2. 귀납 추론 (Inductive Reasoning)
- 구체적 사례에서 일반 규칙 도출
- 통계적, 확률적

### 3. 유추 추론 (Analogical Reasoning)
- 유사한 사례에서 추론

## RDFS 기반 추론

### 기본 추론 규칙

#### 1. SubClassOf (클래스 계층)
```turtle
# 공리
Employee rdfs:subClassOf Person .
Manager rdfs:subClassOf Employee .

# 데이터
Alice a Manager .

# 추론
Alice a Employee .  # 1단계
Alice a Person .    # 2단계
```

#### 2. SubPropertyOf (속성 계층)
```turtle
# 공리
hasBiologicalParent rdfs:subPropertyOf hasParent .

# 데이터
Bob hasBiologicalParent Mary .

# 추론
Bob hasParent Mary .
```

#### 3. Domain과 Range
```turtle
# 공리
teaches rdfs:domain Trainer .
teaches rdfs:range Member .

# 데이터
Kim teaches Park .

# 추론
Kim a Trainer .     # domain 추론
Park a Member .     # range 추론
```

### RDFS 추론 예제

```turtle
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix ex: <http://example.org/> .

# 스키마 정의
ex:Person a rdfs:Class .
ex:Employee rdfs:subClassOf ex:Person .
ex:Manager rdfs:subClassOf ex:Employee .

ex:worksAt a rdf:Property ;
    rdfs:domain ex:Employee ;
    rdfs:range ex:Company .

# 인스턴스 데이터
ex:Alice a ex:Manager .
ex:Alice ex:worksAt ex:Google .

# 추론 결과:
# ex:Alice a ex:Employee    (Manager → Employee)
# ex:Alice a ex:Person      (Employee → Person)
# ex:Google a ex:Company    (worksAt의 range)
```

## OWL 기반 추론

OWL은 RDFS보다 훨씬 강력한 추론 능력을 제공합니다.

### 1. 속성 특성 추론

#### InverseOf
```turtle
# 공리
hasParent owl:inverseOf hasChild .

# 데이터
Bob hasParent John .

# 추론
John hasChild Bob .
```

#### SymmetricProperty
```turtle
# 공리
hasSpouse a owl:SymmetricProperty .

# 데이터
John hasSpouse Mary .

# 추론
Mary hasSpouse John .
```

#### TransitiveProperty
```turtle
# 공리
hasAncestor a owl:TransitiveProperty .

# 데이터
Bob hasAncestor John .
John hasAncestor Robert .

# 추론
Bob hasAncestor Robert .
```

#### FunctionalProperty
```turtle
# 공리
hasBirthMother a owl:FunctionalProperty .

# 데이터
Bob hasBirthMother Mary .
Bob hasBirthMother Jane .

# 추론
Mary owl:sameAs Jane .  # 동일인물
```

### 2. 클래스 표현식 추론

#### Equivalent Class
```turtle
# 공리
Parent owl:equivalentClass [
    a owl:Class ;
    owl:intersectionOf (
        Person
        [
            a owl:Restriction ;
            owl:onProperty hasChild ;
            owl:minCardinality 1
        ]
    )
] .

# 데이터
John hasChild Bob .

# 추론
John a Parent .
```

#### Disjoint Classes
```turtle
# 공리
Male owl:disjointWith Female .

# 데이터
Alice a Male .
Alice a Female .

# 추론
❌ 일관성 오류! (Inconsistency)
```

### 3. 제약 조건 추론

#### SomeValuesFrom
```turtle
# 공리: "모든 트레이너는 최소 1명의 회원을 가르친다"
Trainer rdfs:subClassOf [
    a owl:Restriction ;
    owl:onProperty teaches ;
    owl:someValuesFrom Member
] .

# 데이터
Kim a Trainer .

# 추론
# Kim은 반드시 최소 1명의 회원을 가르쳐야 함
# (데이터가 없으면 일관성 오류는 아니지만, Open World Assumption)
```

#### AllValuesFrom
```turtle
# 공리: "트레이너가 가르치는 모든 대상은 회원이다"
Trainer rdfs:subClassOf [
    a owl:Restriction ;
    owl:onProperty teaches ;
    owl:allValuesFrom Member
] .

# 데이터
Kim a Trainer .
Kim teaches Park .

# 추론
Park a Member .
```

## 추론 엔진

### 1. HermiT
- OWL 2 DL 완전 지원
- 가장 정확
- 속도는 중간

**사용법 (Owlready2)**:
```python
from owlready2 import *

onto = get_ontology("family.owl").load()
sync_reasoner_hermit(onto)
```

### 2. Pellet
- OWL 2 지원
- 안정적
- Java 기반

**사용법**:
```python
sync_reasoner_pellet(onto)
```

### 3. ELK
- OWL 2 EL 프로파일
- 매우 빠름
- 대규모 온톨로지에 적합

### 4. Fact++
- OWL 2 DL
- 빠름
- C++ 기반

## 실습 예제

### 예제 1: 가족 관계 추론

```python
from owlready2 import *

# 온톨로지 생성
onto = get_ontology("http://example.org/family.owl")

with onto:
    class Person(Thing):
        pass

    class hasParent(ObjectProperty, TransitiveProperty):
        domain = [Person]
        range = [Person]

    class hasChild(ObjectProperty):
        inverse_property = hasParent

    # 인스턴스
    grandpa = Person("Grandpa")
    john = Person("John")
    bob = Person("Bob")

    john.hasParent = [grandpa]
    bob.hasParent = [john]

print("추론 전:")
print(f"Bob의 부모: {bob.hasParent}")
print(f"John의 자녀: {john.hasChild if hasattr(john, 'hasChild') else '없음'}")

# 추론 실행
sync_reasoner_pellet(infer_property_values=True)

print("\n추론 후:")
print(f"Bob의 부모: {bob.hasParent}")
print(f"John의 자녀: {john.hasChild}")
print(f"Bob의 조상 (추이): {[p.name for p in bob.hasParent]}")
```

**결과**:
```
추론 전:
Bob의 부모: [family.John]
John의 자녀: 없음

추론 후:
Bob의 부모: [family.John, family.Grandpa]  # 추이 속성
John의 자녀: [family.Bob]                   # 역속성
```

### 예제 2: 클래스 추론

```python
from owlready2 import *

onto = get_ontology("http://example.org/fitness.owl")

with onto:
    class Person(Thing):
        pass

    class Trainer(Person):
        pass

    class Member(Person):
        pass

    class teaches(ObjectProperty):
        domain = [Trainer]
        range = [Member]

    # 데이터 (클래스 정보 없음)
    kim = Person("Kim")
    park = Person("Park")
    kim.teaches = [park]

print("추론 전:")
print(f"Kim의 타입: {kim.is_a}")
print(f"Park의 타입: {park.is_a}")

# 추론 실행
sync_reasoner_pellet()

print("\n추론 후:")
print(f"Kim의 타입: {kim.is_a}")
print(f"Park의 타입: {park.is_a}")
```

**결과**:
```
추론 전:
Kim의 타입: [fitness.Person]
Park의 타입: [fitness.Person]

추론 후:
Kim의 타입: [fitness.Person, fitness.Trainer]   # domain 추론
Park의 타입: [fitness.Person, fitness.Member]   # range 추론
```

### 예제 3: 일관성 체크

```python
from owlready2 import *

onto = get_ontology("http://example.org/test.owl")

with onto:
    class Male(Thing):
        pass

    class Female(Thing):
        pass

    # Male과 Female은 서로소
    AllDisjoint([Male, Female])

    # 데이터
    alice = Male("Alice")
    alice.is_a.append(Female)  # 모순!

try:
    sync_reasoner_pellet()
    print("온톨로지가 일관적입니다.")
except OwlReadyInconsistentOntologyError:
    print("❌ 일관성 오류: Alice는 Male이면서 Female일 수 없습니다!")
```

## SPARQL과 추론

### 추론 포함 쿼리

```python
from rdflib import Graph
from rdflib.plugins.sparql import prepareQuery

g = Graph()
g.parse("family-ontology.ttl", format="turtle")

# SPARQL 쿼리 (추론 없이)
query = """
PREFIX family: <http://example.org/family#>

SELECT ?child ?parent
WHERE {
    ?child family:hasParent ?parent .
}
"""

print("명시적 hasParent 관계:")
for row in g.query(query):
    print(f"  {row.child} → {row.parent}")

# 추론 후 쿼리 (역관계)
query_inferred = """
PREFIX family: <http://example.org/family#>

SELECT ?parent ?child
WHERE {
    ?parent family:hasChild ?child .
}
"""

print("\n추론된 hasChild 관계:")
for row in g.query(query_inferred):
    print(f"  {row.parent} → {row.child}")
```

## 추론 최적화

### 1. 증분 추론 (Incremental Reasoning)
- 데이터가 추가될 때마다 전체 추론을 다시 하지 않음
- 변경된 부분만 재계산

### 2. 모듈화 (Modularization)
- 큰 온톨로지를 작은 모듈로 분리
- 필요한 모듈만 추론

### 3. 프로파일 선택
- OWL 2 EL: 빠른 추론이 필요할 때
- OWL 2 QL: 데이터베이스 통합
- OWL 2 DL: 최대 표현력

## 실습 과제

### 과제 1: 조직 구조 추론
다음을 모델링하고 추론하세요:
```
CEO → VP → Manager → Employee
```
- `reportsTo` (TransitiveProperty)
- SPARQL로 CEO에게 보고하는 모든 사람 찾기

### 과제 2: 운동 추천 추론
피트니스 온톨로지에서:
- 회원이 선호하는 근육 그룹
- 해당 근육을 타겟하는 운동 자동 추론
- 추천 운동 목록 생성

### 과제 3: 일관성 검증
다음 규칙을 체크하세요:
- 사람은 Male 또는 Female (하나만)
- 트레이너는 최소 1명의 회원을 가르침
- 회원의 남은 세션 >= 0

## 추론의 한계

### Open World Assumption (OWA)
```turtle
# 데이터
Bob a Person .

# 질문: "Bob은 자녀가 없는가?"
# 답변: "모른다" (Not "False")
```

- 명시되지 않은 것은 "알 수 없음"
- DB의 Closed World Assumption과 다름

### 성능
- 복잡한 온톨로지는 추론이 느림
- 대규모 데이터에서 병목
- 해결: 프로파일 선택, 증분 추론

### 비결정성 (Non-determinism)
- 일부 추론은 여러 해가 가능
- 추론 엔진마다 결과가 다를 수 있음

## 핵심 요점

1. **추론은 명시적 지식에서 암묵적 지식 유도**
2. **RDFS**: 기본 추론 (계층, domain/range)
3. **OWL**: 강력한 추론 (속성 특성, 제약 조건)
4. **추론 엔진**: HermiT, Pellet, ELK
5. **일관성 체크**: 모순 자동 감지
6. **Open World Assumption**: 모르는 것은 "알 수 없음"

## 참고 자료

- [OWL 2 Web Ontology Language Profiles](https://www.w3.org/TR/owl2-profiles/)
- [Description Logic Reasoning](https://en.wikipedia.org/wiki/Description_logic)
- [Owlready2 Documentation - Reasoning](https://owlready2.readthedocs.io/en/latest/reasoning.html)

---

**학습일**:
**완료 여부**: [ ]
**추론 실습**: [ ]
